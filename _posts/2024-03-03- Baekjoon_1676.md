---
title: [백준] 팩토리얼 0의 개수 - 1676
date: 2024-03-03 18:28:00 +09:00
categories: [백준]
tags:
  [
    백준,
    알고리즘,
    수학
  ]
---

## 생각한 방법 - 1
당연히 첫번째는 바로, 무지성 돌격. 바로 팩토리얼을 구하고 0의 개수를 센다

하지만 결과는 멸망. 왜냐? 당연히 숫자가 너무 커진다. 범위를 아득히 넘어선다 long long int를 써도 안된다.

9,223,372,036,854,775,807이라는 엄청난 범위조차 122013682599111006870123878542304692625357434280319284219241
358838584537315388199760549644750220328186301361647714820358
416337872207817720048078520515932928547790757193933060377296
085908627042917454788242...라는 500!에는 쨉도 안되기 때문이다.


## 생각한 방법 - 2
1. 뒤에 0이 오는 족족 떼어내고 카운트한다.
2. 앞에 숫자가 많으면 떼어낸다. 0이 될 수 있는 1, 2, 5를 제외하고 제거한다.

10의 약수인 대략 1, 2, 5가 아니면 없어도 되는건가?... 뭐 이런 생각을 하다보니, 반례가 많았다. 예를 들어... 6000에 5를 곱하면 30000이 되어 0이 늘었다.

그러다 문득 스친 생각이 있었으니...



## 생각한 방법 - 3
약수...그래 약수야. 그냥 2와 5만 있으면 되는 거였어!!!!

이 생각이 나서 바로 코드를 싹다 바꿨다. 바꾸고 보니 너무 간단하다. for문 저건... 그냥 하다보니까 역으로 내려가게 짰다. 의미는 없다.

```C
#include <math.h>
#include <stdio.h>

int main(void) {
  int n;

  int two_count = 0;
  int five_count = 0;

  scanf("%d", &n);

  for (int i = n; i > 0; i--) {
    int number = i;
    while (number % 2 == 0) {
      number /= 2;
      two_count += 1;
    }
    while (number % 5 == 0) {
      number /= 5;
      five_count += 1;
    }
  }

  if (five_count > two_count) {
    printf("%d", two_count);
  } else {
    printf("%d", five_count);
  }

  return 0;
}
```


## 풀고나서
글을 보니까 문자열 느낌으로다가 직접 곱해가면서 풀 수도 있다고 한다. 엄...어떻게?

그리도 또... 보다보니 파이썬이면 숫자 크기 제한따위 무시해버릴 수 있단 걸 알아냈다. 아... 또 당신입니까 Py-Man...